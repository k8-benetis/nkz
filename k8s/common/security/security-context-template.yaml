# =============================================================================
# Security Context - Configuración de Seguridad para Contenedores
# =============================================================================
# Estas configuraciones deben aplicarse a TODOS los deployments
# Siguen el principio de mínimo privilegio
# =============================================================================

---
# =============================================================================
# Template de Security Context - A nivel de Pod
# =============================================================================
# Aplicar a spec.template.spec.securityContext

# Security Context a nivel de Pod
podSecurityContext:
  # Ejecutar como usuario no root
  runAsNonRoot: true
  runAsUser: 1000      # UID del usuario
  runAsGroup: 1000     # GID del grupo
  fsGroup: 1000        # Grupo para volúmenes
  
  # Configuraciones adicionales de seguridad
  seccompProfile:
    type: RuntimeDefault  # Usa el perfil seccomp por defecto
  
  # Deshabilitar escalada de privilegios
  #fsGroupChangePolicy: "OnRootMismatch"  # Solo cambiar ownership si es necesario

---
# =============================================================================
# Template de Security Context - A nivel de Contenedor
# =============================================================================
# Aplicar a spec.template.spec.containers[].securityContext

containerSecurityContext:
  # Deshabilitar escalada de privilegios
  allowPrivilegeEscalation: false
  
  # Ejecutar como usuario no root
  runAsNonRoot: true
  runAsUser: 1000
  runAsGroup: 1000
  
  # Filesystem de solo lectura
  readOnlyRootFilesystem: true
  
  # Eliminar todas las capabilities
  capabilities:
    drop:
    - ALL
    # Añadir solo las capabilities necesarias (si aplica)
    # add:
    # - NET_BIND_SERVICE  # Solo si necesita binding a puertos < 1024
  
  # Perfil seccomp
  seccompProfile:
    type: RuntimeDefault

---
# =============================================================================
# ConfigMap con Security Context por tipo de servicio
# =============================================================================

apiVersion: v1
kind: ConfigMap
metadata:
  name: security-contexts
  namespace: nekazari-system
  labels:
    app: nekazari
    component: security
data:
  # Para servicios de aplicación (APIs, microservicios)
  application-service.yaml: |
    podSecurityContext:
      runAsNonRoot: true
      runAsUser: 1000
      runAsGroup: 1000
      fsGroup: 1000
      seccompProfile:
        type: RuntimeDefault
    
    containerSecurityContext:
      allowPrivilegeEscalation: false
      runAsNonRoot: true
      runAsUser: 1000
      runAsGroup: 1000
      readOnlyRootFilesystem: true
      capabilities:
        drop:
        - ALL

  # Para bases de datos (requieren permisos de escritura en volúmenes)
  database-service.yaml: |
    podSecurityContext:
      runAsNonRoot: true
      runAsUser: 999       # Usuario postgres estándar
      runAsGroup: 999
      fsGroup: 999
      seccompProfile:
        type: RuntimeDefault
    
    containerSecurityContext:
      allowPrivilegeEscalation: false
      runAsNonRoot: true
      runAsUser: 999
      runAsGroup: 999
      readOnlyRootFilesystem: false  # Bases de datos necesitan escribir
      capabilities:
        drop:
        - ALL

  # Para Nginx (necesita binding a puerto 80)
  nginx-service.yaml: |
    podSecurityContext:
      runAsNonRoot: false  # Nginx en Alpine puede necesitar root inicialmente
      runAsUser: 101       # Usuario nginx en Alpine
      runAsGroup: 101
      fsGroup: 101
      seccompProfile:
        type: RuntimeDefault
    
    containerSecurityContext:
      allowPrivilegeEscalation: false
      runAsNonRoot: false
      runAsUser: 101
      readOnlyRootFilesystem: true
      capabilities:
        drop:
        - ALL
        add:
        - NET_BIND_SERVICE  # Para binding a puerto 80/443
        - CHOWN
        - SETGID
        - SETUID

  # Para Mosquitto (necesita permisos específicos)
  mosquitto-service.yaml: |
    podSecurityContext:
      runAsNonRoot: true
      runAsUser: 1883      # Usuario mosquitto estándar
      runAsGroup: 1883
      fsGroup: 1883
      seccompProfile:
        type: RuntimeDefault
    
    containerSecurityContext:
      allowPrivilegeEscalation: false
      runAsNonRoot: true
      runAsUser: 1883
      runAsGroup: 1883
      readOnlyRootFilesystem: false  # Mosquitto necesita escribir logs/persistence
      capabilities:
        drop:
        - ALL

  # Para WireGuard VPN (necesita privilegios de red)
  wireguard-service.yaml: |
    podSecurityContext:
      # WireGuard requiere más privilegios
      runAsNonRoot: false
      seccompProfile:
        type: RuntimeDefault
    
    containerSecurityContext:
      # WireGuard necesita capacidades de red
      allowPrivilegeEscalation: true
      privileged: false
      capabilities:
        drop:
        - ALL
        add:
        - NET_ADMIN
        - SYS_MODULE
        - NET_RAW

---
# =============================================================================
# Script para actualizar deployments existentes
# =============================================================================

apiVersion: v1
kind: ConfigMap
metadata:
  name: security-context-patcher
  namespace: nekazari-system
  labels:
    app: nekazari
    component: security-tools
data:
  patch-deployments.sh: |
    #!/bin/bash
    # Script para añadir Security Context a deployments existentes
    
    set -e
    
    NAMESPACE="${1:-nekazari}"
    
    echo "======================================"
    echo "Security Context Patcher"
    echo "Namespace: $NAMESPACE"
    echo "======================================"
    
    # Función para parchear un deployment
    patch_deployment() {
      local deployment=$1
      local security_type=$2
      
      echo "Parcheando $deployment con perfil $security_type..."
      
      case $security_type in
        "application")
          kubectl patch deployment $deployment -n $NAMESPACE --type='json' -p='[
            {
              "op": "add",
              "path": "/spec/template/spec/securityContext",
              "value": {
                "runAsNonRoot": true,
                "runAsUser": 1000,
                "runAsGroup": 1000,
                "fsGroup": 1000,
                "seccompProfile": {"type": "RuntimeDefault"}
              }
            },
            {
              "op": "add",
              "path": "/spec/template/spec/containers/0/securityContext",
              "value": {
                "allowPrivilegeEscalation": false,
                "runAsNonRoot": true,
                "runAsUser": 1000,
                "runAsGroup": 1000,
                "readOnlyRootFilesystem": true,
                "capabilities": {"drop": ["ALL"]}
              }
            }
          ]'
          ;;
        
        "database")
          kubectl patch deployment $deployment -n $NAMESPACE --type='json' -p='[
            {
              "op": "add",
              "path": "/spec/template/spec/securityContext",
              "value": {
                "runAsNonRoot": true,
                "runAsUser": 999,
                "runAsGroup": 999,
                "fsGroup": 999,
                "seccompProfile": {"type": "RuntimeDefault"}
              }
            },
            {
              "op": "add",
              "path": "/spec/template/spec/containers/0/securityContext",
              "value": {
                "allowPrivilegeEscalation": false,
                "runAsNonRoot": true,
                "runAsUser": 999,
                "runAsGroup": 999,
                "readOnlyRootFilesystem": false,
                "capabilities": {"drop": ["ALL"]}
              }
            }
          ]'
          ;;
      esac
    }
    
    # Parchear servicios de aplicación
    echo ""
    echo "Parcheando servicios de aplicación..."
    for deployment in api-gateway api-validator entity-manager activation-codes; do
      if kubectl get deployment $deployment -n $NAMESPACE &>/dev/null; then
        patch_deployment $deployment "application"
      else
        echo "⚠️  Deployment $deployment no encontrado"
      fi
    done
    
    # Parchear bases de datos
    echo ""
    echo "Parcheando servicios de bases de datos..."
    for deployment in postgresql mongodb; do
      if kubectl get deployment $deployment -n $NAMESPACE &>/dev/null; then
        patch_deployment $deployment "database"
      else
        echo "⚠️  Deployment $deployment no encontrado"
      fi
    done
    
    echo ""
    echo "✅ Security Context aplicado a todos los deployments"

  verify-security.sh: |
    #!/bin/bash
    # Script para verificar Security Context en deployments
    
    NAMESPACE="${1:-nekazari}"
    
    echo "======================================"
    echo "Security Context Verification"
    echo "Namespace: $NAMESPACE"
    echo "======================================"
    echo ""
    
    # Obtener todos los deployments
    deployments=$(kubectl get deployments -n $NAMESPACE -o name)
    
    total=0
    secure=0
    insecure=0
    
    for deployment in $deployments; do
      total=$((total + 1))
      name=$(echo $deployment | cut -d'/' -f2)
      
      # Verificar si tiene securityContext
      has_pod_security=$(kubectl get $deployment -n $NAMESPACE -o jsonpath='{.spec.template.spec.securityContext}')
      has_container_security=$(kubectl get $deployment -n $NAMESPACE -o jsonpath='{.spec.template.spec.containers[0].securityContext}')
      
      if [ -n "$has_pod_security" ] && [ -n "$has_container_security" ]; then
        echo "✅ $name - Security Context configurado"
        secure=$((secure + 1))
      else
        echo "❌ $name - Security Context FALTA"
        insecure=$((insecure + 1))
      fi
    done
    
    echo ""
    echo "======================================"
    echo "Resumen:"
    echo "Total: $total deployments"
    echo "Seguros: $secure"
    echo "Inseguros: $insecure"
    echo "======================================"
    
    if [ $insecure -gt 0 ]; then
      exit 1
    fi

---
# =============================================================================
# Job para aplicar Security Context automáticamente
# =============================================================================

apiVersion: batch/v1
kind: Job
metadata:
  name: apply-security-contexts
  namespace: nekazari-system
  labels:
    app: nekazari
    component: security-setup
spec:
  template:
    spec:
      serviceAccountName: security-patcher-sa
      restartPolicy: OnFailure
      containers:
      - name: patcher
        image: bitnami/kubectl:latest
        command: ["/bin/bash"]
        args:
          - /scripts/patch-deployments.sh
          - nekazari
        volumeMounts:
        - name: scripts
          mountPath: /scripts
      volumes:
      - name: scripts
        configMap:
          name: security-context-patcher
          defaultMode: 0755

---
# ServiceAccount con permisos para parchear deployments
apiVersion: v1
kind: ServiceAccount
metadata:
  name: security-patcher-sa
  namespace: nekazari-system

---
apiVersion: rbac.authorization.k8s.io/v1
kind: Role
metadata:
  name: security-patcher-role
  namespace: nekazari
rules:
- apiGroups: ["apps"]
  resources: ["deployments"]
  verbs: ["get", "list", "patch", "update"]

---
apiVersion: rbac.authorization.k8s.io/v1
kind: RoleBinding
metadata:
  name: security-patcher-binding
  namespace: nekazari
subjects:
- kind: ServiceAccount
  name: security-patcher-sa
  namespace: nekazari-system
roleRef:
  kind: Role
  name: security-patcher-role
  apiGroup: rbac.authorization.k8s.io
